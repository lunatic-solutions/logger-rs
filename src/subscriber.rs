pub mod fmt;

use std::ops::{Deref, DerefMut};

use serde::{ser::SerializeTuple, Deserialize, Serialize};
use vtable::{VBox, VRef, VRefMut};

// #[vtable]
// pub struct SubscriberVTable {
//     enabled: fn(VRef<SubscriberVTable>, metadata: &tracing::Metadata<'_>) -> bool,
//     event: fn(VRef<SubscriberVTable>, event: &tracing::Event<'_>),
//     drop: fn(VRefMut<SubscriberVTable>),
// }

#[allow(non_snake_case)]
#[macro_use]
#[doc = r" This private module is generated by the `vtable` macro"]
mod Subscriber_vtable_mod {
    use super::*;
    use ::vtable::*;
    pub struct SubscriberVTable {
        pub enabled:
            unsafe extern "C" fn(VRef<SubscriberVTable>, metadata: &tracing::Metadata<'_>) -> bool,
        pub event: unsafe extern "C" fn(VRef<SubscriberVTable>, event: &str),
        pub drop: unsafe extern "C" fn(VRefMut<SubscriberVTable>),
    }
    impl SubscriberVTable {
        #[doc = r" Create a vtable suitable for a given type implementing the trait."]
        pub fn new<T: Subscriber>() -> Self {
            Self {
                enabled: {
                    extern "C" fn enabled<T: Subscriber>(
                        _0: VRef<SubscriberVTable>,
                        _1: &tracing::Metadata<'_>,
                    ) -> bool {
                        unsafe {
                            core::mem::transmute::<bool, bool>(T::enabled(
                                &(*(_0.as_ptr() as *const T)),
                                _1,
                            ))
                        }
                    }
                    enabled::<T>
                },
                event: {
                    extern "C" fn event<T: Subscriber>(_0: VRef<SubscriberVTable>, _1: &str) {
                        unsafe { (T::event(&(*(_0.as_ptr() as *const T)), _1)) }
                    }
                    event::<T>
                },
                drop: {
                    extern "C" fn drop<T: Subscriber>(_0: VRefMut<SubscriberVTable>) {
                        unsafe {
                            Box::from_raw((&mut (*(_0.as_ptr() as *mut T)),).0 as *mut _);
                        }
                    }
                    drop::<T>
                },
            }
        }
    }
    #[doc = "\nNote: Was generated from the [`#[vtable]`](vtable) macro on [`SubscriberVTable`]"]
    pub trait Subscriber {
        fn enabled(&self, _1: &tracing::Metadata<'_>) -> bool;

        fn event(&self, _1: &str);
    }
    #[doc = r" Invariant, same as vtable::Inner: vtable and ptr has to be valid and ptr an instance matching the vtable"]
    #[doc(hidden)]
    #[repr(C)]
    pub struct SubscriberTO {
        pub(super) vtable: core::ptr::NonNull<SubscriberVTable>,
        pub(super) ptr: core::ptr::NonNull<u8>,
    }
    impl SubscriberTO {
        pub fn enabled(&self, _1: &tracing::Metadata<'_>) -> bool {
            unsafe {
                let vtable = self.vtable.as_ref();
                if let (func) = vtable.enabled {
                    func(
                        <VRef<SubscriberVTable>>::from_raw(self.vtable, self.ptr),
                        _1,
                    )
                } else {
                    panic!("Called a not-implemented method")
                }
            }
        }
        pub fn event(&self, _1: &str) {
            unsafe {
                let vtable = self.vtable.as_ref();
                if let (func) = vtable.event {
                    func(
                        <VRef<SubscriberVTable>>::from_raw(self.vtable, self.ptr),
                        _1,
                    )
                } else {
                    panic!("Called a not-implemented method")
                }
            }
        }
        #[doc = r" Returns a reference to the VTable"]
        pub fn get_vtable(&self) -> &SubscriberVTable {
            unsafe { self.vtable.as_ref() }
        }
        #[doc = r" Return a raw pointer to the object"]
        pub fn as_ptr(&self) -> *const u8 {
            self.ptr.as_ptr()
        }
    }
    unsafe impl VTableMeta for SubscriberVTable {
        type VTable = SubscriberVTable;
        type Target = SubscriberTO;
    }
    unsafe impl VTableMetaDrop for SubscriberVTable {
        unsafe fn drop(ptr: *mut SubscriberTO) {
            unsafe {
                let ptr = &*ptr;
                (ptr.vtable.as_ref().drop)(VRefMut::from_raw(ptr.vtable, ptr.ptr))
            }
        }
        fn new_box<X: HasStaticVTable<SubscriberVTable>>(value: X) -> VBox<SubscriberVTable> {
            let ptr = core::ptr::NonNull::from(Box::leak(Box::new(value)));
            unsafe { VBox::from_raw(core::ptr::NonNull::from(X::static_vtable()), ptr.cast()) }
        }
    }
}
#[doc(inline)]
pub use Subscriber_vtable_mod::*;
#[macro_export]
#[doc = "Instantiate a static SubscriberVTable for a given type and implements `vtable::HasStaticVTable<SubscriberVTable>` for it.\n\n```ignore\n// The preview above is misleading because of rust-lang/rust#45939, so it is reproduced below\nmacro_rules! SubscriberVTable_static {\n    ($(#[$meta:meta])* $vis:vis static $ident:ident for $ty:ty) => { ... }\n}\n```\n\nGiven a type `MyType` that implements the trait `Subscriber `,\ncreate a static variable of type SubscriberVTable,\nand implements HasStaticVTable for it.\n\n```ignore\n    struct Foo { ... }\n    impl Subscriber for Foo { ... }\n    SubscriberVTable_static!(static FOO_VTABLE for Foo);\n    // now VBox::new can be called\n    let vbox = VBox::new(Foo{ ... });\n```\n\n        \nNote: Was generated from the [`#[vtable]`](vtable) macro on [`SubscriberVTable`]"]
macro_rules! SubscriberVTable_static {
  ($(#[$meta:meta])* $vis:vis static$ident:ident for$ty:ty) => {
    $(#[$meta])* $vis static $ident: $crate::subscriber::SubscriberVTable = {
      use vtable:: * ;
      type T =  $ty;
      $crate::subscriber::SubscriberVTable {
        enabled:{
          extern "C" fn enabled<T:Subscriber>(_0:VRef<$crate::subscriber::SubscriberVTable> ,_1: &tracing::Metadata< '_>)->bool {
            unsafe {
              core::mem::transmute:: <bool,bool>(T::enabled(&(*(_0.as_ptr()as *const T)),_1,))
            }
          }enabled:: <T>
        },event:{
          extern "C" fn event<T:Subscriber>(_0:VRef<$crate::subscriber::SubscriberVTable> ,_1: &str){
            unsafe {
              (T::event(&(*(_0.as_ptr()as *const T)),_1,))
            }
          }event:: <T>
        },drop:{
            extern "C" fn drop<T:Subscriber>(_0:VRefMut<$crate::subscriber::SubscriberVTable>){
              unsafe {
                Box::from_raw((&mut(*(_0.as_ptr()as *mut T)),).0 as *mut _);

                }
            }drop:: <T>
        },
      }
    };
    unsafe impl vtable::HasStaticVTable<$crate::subscriber::SubscriberVTable>for$ty {
      fn static_vtable()-> & 'static $crate::subscriber::SubscriberVTable {
        & $ident
      }
    }
  }
}

pub struct SubscriberInstance(pub(crate) VBox<SubscriberVTable>);

impl Deref for SubscriberInstance {
    type Target = VBox<SubscriberVTable>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for SubscriberInstance {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Serialize for SubscriberInstance {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let vtable_ptr = self.0.vtable.as_ptr() as u64;
        let ptr_ptr = self.0.ptr.as_ptr() as u64;

        let mut tuple = serializer.serialize_tuple(2)?;
        tuple.serialize_element(&vtable_ptr)?;
        tuple.serialize_element(&ptr_ptr)?;
        tuple.end()
    }
}

impl<'de> Deserialize<'de> for SubscriberInstance {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let (vtable_ptr, ptr_ptr) = <(u64, u64)>::deserialize(deserializer)?;
        unsafe {
            let vtable = std::ptr::NonNull::new_unchecked(vtable_ptr as *mut SubscriberVTable);
            let ptr = std::ptr::NonNull::new_unchecked(ptr_ptr as *mut u8);
            Ok(SubscriberInstance(VBox::from_raw(vtable, ptr)))
        }
    }
}

impl Serialize for SubscriberTO {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let vtable_ptr = self.vtable.as_ptr() as u64;
        let ptr_ptr = self.ptr.as_ptr() as u64;

        let mut tuple = serializer.serialize_tuple(2)?;
        tuple.serialize_element(&vtable_ptr)?;
        tuple.serialize_element(&ptr_ptr)?;
        tuple.end()
    }
}

impl<'de> Deserialize<'de> for SubscriberTO {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let (vtable_ptr, ptr_ptr) = <(u64, u64)>::deserialize(deserializer)?;
        unsafe {
            let vtable = std::ptr::NonNull::new_unchecked(vtable_ptr as *mut SubscriberVTable);
            let ptr = std::ptr::NonNull::new_unchecked(ptr_ptr as *mut u8);
            Ok(SubscriberTO { vtable, ptr })
        }
    }
}

// impl Serialize for SubscriberVTable {
//     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
//     where
//         S: serde::Serializer,
//     {
//         let enabled_ptr = self.enabled as *const () as u64;
//         let event_ptr = self.event as *const () as u64;

//         let tuple = serializer.serialize_tuple(2)?;
//         tuple.serialize_element(&enabled_ptr)?;
//         tuple.serialize_element(&event_ptr)?;
//         tuple.end()
//     }
// }

// impl<'de> Deserialize<'de> for SubscriberVTable {
//     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
//     where
//         D: serde::Deserializer<'de>,
//     {
//         let (enabled_ptr, event_ptr) = <(u64, u64)>::deserialize(deserializer)?;
//         unsafe {
//             let enabled = mem::transmute::<*const (), _>(enabled_ptr as *const ());
//             let event = mem::transmute::<*const (), _>(event_ptr as *const ());
//             Ok(SubscriberVTable { enabled, event })
//         }
//     }
// }

// pub trait Subscriber {
//     fn enabled(&self, metadata: &Metadata<'_>) -> bool;

//     fn event(&self, event: &Event<'_>);

//     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
//     where
//         S: serde::Serializer;

//     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
//     where
//         D: serde::Deserializer<'de>;
// }

// impl Serialize for dyn Subscriber {
//     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
//     where
//         S: serde::Serializer,
//     {
//         self.serialize(serializer)
//     }
// }

// impl<'de> Deserialize<'de> for dyn Subscriber {
//     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
//     where
//         D: serde::Deserializer<'de>,
//     {
//         Self::serialize(deserializer)
//     }
// }
